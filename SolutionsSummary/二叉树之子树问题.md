### 框架
```python3
def isSubStructure(self, A: TreeNode, B: TreeNode) -> bool:
        def sameroot(A, B):
            # base case #
            return A.val == B.val and sameroot(A.left, B.left) and sameroot(A.right, B.right)
        # base case #
        return self.isSubStructure(A.left, B) or self.isSubStructure(A.right, B) or sameroot(A, B)
```     
> 注意： 不同子树题目要求不一样。      
《面26》要求B是A其中一只分支即认为是子树；                 
题572认为**t**必须是**s**的全部子集才认为是子树，从而写的base case也不相同！
- [面试题26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)
```shell
输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)      
B是A的子结构， 即 A中有出现和B相同的结构和节点值。          
例如:
给定的树 A:

     3
    / \
   4   5
  / \
 1   2
给定的树 B：

   4 
  /
 1
返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。
```
示例 1：
```shell
输入：A = [1,2,3], B = [3,1]
输出：false
```     
示例 2：
```shell
输入：A = [3,4,5,1,2], B = [4,1]
输出：true
```
运用框架解题：
```python3
class Solution:
    def isSubStructure(self, A: TreeNode, B: TreeNode) -> bool:
        def sameroot(A, B):
            # 递归时候，B为空，则返回True，注意跟后面的not B区别
            if not B: return True
            if not A: return not B 
            return A.val == B.val and sameroot(A.left, B.left) and sameroot(A.right, B.right)
        # 在sameroot之外，B为空即认为不是子集
        if not B: return False
        # 输入的A可能为空，或者self.isSubStructure递归时候为空，故需要此base case
        if not A: return not B
        return self.isSubStructure(A.left, B) or self.isSubStructure(A.right, B) or sameroot(A, B)
```

- [572. 另一个树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)
```shell
给定两个非空二叉树 **s** 和 **t**，检验 **s** 中是否包含和 **t** 具有相同结构和节点值的子树。**s** 的一个子树包括 **s** 的一个节点和这个节点的所有子孙。**s** 也可以看做它自身的一棵子树。

示例 1:
给定的树 s:

     3
    / \
   4   5
  / \
 1   2
给定的树 t：

   4 
  / \
 1   2
返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。

示例 2:
给定的树 s：

     3
    / \
   4   5
  / \
 1   2
    /
   0
给定的树 t：

   4
  / \
 1   2
返回 false。
```       
解题
```python3
class Solution:
    def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:
        def sameTree(s, t):
            # 要求t是s的子集，故base case 比《面26》更严格
            if not s and not t: return True
            if not s or not t: return False
            return s.val == t.val and sameTree(s.left, t.left) and sameTree(s.right, t.right)
        # 题目说了s, t均不为空，故base case需要注意： 递归是s为空，因为s在深度递归s.left, s.right,而t不变
        # 也可以写作 if not s and t: return False
        if not s: return False
        return self.isSubtree(s.left, t) or self.isSubtree(s.right, t) or sameTree(s, t)
```

### 其他类似的题目
- [1367. 二叉树中的列表](https://leetcode-cn.com/problems/linked-list-in-binary-tree/)
```python3
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:
        def match(head, root):
            if not head: return True
            if not root: return False
            if root.val != head.val: return False
            return match(head.next, root.left) or match(head.next, root.right)
        if not head: return True
        if not root: return False
        if match(head, root): return True
        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)
        
```
