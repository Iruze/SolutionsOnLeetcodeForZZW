# 参考：
- [递归反转链表：如何拆解复杂问题](https://mp.weixin.qq.com/s/5wz_YJ3lTkDH3nWfVDi5SA)
- [递归思维：k 个一组反转链表](https://mp.weixin.qq.com/s/A-dQ9spsP_Iu1Y4iCRP9nA)

# 反转链表类总结

- [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)
```python3
def reverseList(self, head):
    if not head.next:
        return head
    last = self.reverseList(head.next)
    head.next.next = head
    head.next = None
    return last
```

- [00. 反转链表中的前N个节点]()
```python3
def reverseN(self, head, n):
    if n == 1:
        # 记录第 n + 1 个节点
        successor = head.next
        return head
    # 以 head.next 为起点，需要反转前 n - 1 个节点
    last = self.reverseN(head.next, n - 1)
    
    head.next.next = head
    # 让反转之后的 head 节点和后面的节点连起来
    head.next = successor
    return last
```


- [92. 反转链表 II-反转从m到n的链表](https://leetcode-cn.com/problems/reverse-linked-list-ii/)
```python3
def reverseBetween(self, head, m, n):
    if m == 1:
        # 相当于反转前 n 个元素
        return self.reverseN(head, n)
    # 前进到反转的起点触发 base case
    head.next = self.reverseBetween(head.next, m - 1, n - 1)
    return head
```


- [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)
```python3
def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
    def reverseBetween(a, b):
        """
        反转[a, b)的节点，不包括b；
        且反转后， a.next临时指向None
        """
        pre, cur = None, a
        while cur != b:
            nxt = cur.next
            cur.next = pre
            pre, cur = cur, nxt
        return pre
    a, b = head, head
    for i in range(k):
        # k不到链表的长度，无需反转
        if not b: return head
        b = b.next
    # 反转前 k 个元素
    newhead = reverseBetween(a, b)
    # 递归反转后续链表并连接起来
    a.next = self.reverseKGroup(b, k)
    return newhead
```
