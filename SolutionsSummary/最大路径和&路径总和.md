# 基础的路径和问题
- [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

> 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。

示例 :

```
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
```

**注意**：两结点之间的路径长度是以它们之间边的数目表示。
<details>
<summary>题解</summary>
	
```python3
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        self.diameter = 0
        # depth 函数返回的是高度，但是同时实现了直径 Diameter 的计算
        def depth(root):
            if not root: return 0
            l, r = depth(root.left), depth(root.right)
            
            # 去掉这一句，就是求高度 depth 函数的本质
            # 然而，直径正好 = l + r
            self.diameter = max(self.diameter, (l + r))
            
            return 1 + max(l, r)
        depth(root)
        return self.diameter
```
</details>

类似地， 求最大路径和
- [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)
> 给定一个非空二叉树，返回其最大路径和。     
本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。
<details>
<summary>题解</summary>
	
```python3
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        self.maxPath = float('-Inf')
        def helper(root):
            if not root: return 0
            l, r = helper(root.left), helper(root.right)
            self.maxPath = max(self.maxPath, root.val + max(0, l) + max(0, r))
            return root.val + max([0, l, r])
        helper(root)
        return self.maxPath
```
</details>
