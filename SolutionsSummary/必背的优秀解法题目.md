# 分治思想
- [863. 二叉树中所有距离为 K 的结点](https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/)
>给定一个二叉树（具有根结点 `root`）， 一个目标结点 `target` ，和一个整数值 `K `。       
> 返回到目标结点 `target` 距离为 `K` 的所有结点的值的列表。 答案可以以任何顺序返回。

示例 1：
```shell
输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2

输出：[7,4,1]
```

**分治思想 + DFS **
```python3
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def distanceK(self, root: TreeNode, target: TreeNode, K: int) -> List[int]:
        # 从target始往其下的左右子树搜索
        def searchChildren(tar_node, K):
            if not tar_node: return
            if K == 0: ans.append(tar_node.val)
            searchChildren(tar_node.left, K - 1)
            searchChildren(tar_node.right, K - 1)
        # dfs从root始往下遍历
        def dfs(root):
            if not root: return -1
            # base case，找到target节点
            if root.val == target.val:
                searchChildren(root, K)
                return K
            # 分别从左右子树找target
            l = dfs(root.left)
            r = dfs(root.right)
            # target不存在
            if l < 0 and r < 0:
                return -1
            # 因为只有一个target，此时存在于左子树
            elif l > 0:
                # 是左子树第一个节点
                if l == 1: ans.append(root.val)
                # K > 1，则必然存在于右子树
                # 将 K - 1(即l - 1)处理，等价于当前的root是target
                else: searchChildren(root.right, l - 2)
                return l - 1
            # 存在于右子树
            else:
                if r == 1: ans.append(root.val)
                else: searchChildren(root.left, r - 2)
                return r - 1
        ans = []
        dfs(root)
        return ans
```

- [395. 至少有K个重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/)
> 找到给定字符串（由小写字符组成）中的最长子串 **T** ， 要求 **T** 中的每一字符出现次数都不少于 **k** 。输出 **T** 的长度。

示例 1:
```
输入:
s = "aaabb", k = 3

输出:
3

最长子串为 "aaa" ，其中 'a' 重复了 3 次。
```
解法：
```python3
# 分治-递归 思想
class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        if len(s) < k:
            return 0
        # 找到s中出现最少的字符
        t = min(set(s), key=s.count)
        # 最少出现的字符都大于等于K, s即最长子串
        if s.count(t) >= k:
            return len(s)
        # 分治思想，递归求得最长子串
        return max(self.longestSubstring(a, k) for a in s.split(t))
```

# 序列化二叉树
- [652. 寻找重复的子树](https://leetcode-cn.com/problems/find-duplicate-subtrees/)
> 给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。          
两棵树重复是指它们具有相同的结构以及相同的结点值。

```python3
class Solution(object):
    def findDuplicateSubtrees(self, root):
        count = collections.Counter()
        ans = []
        def collect(node):
            if not node: return "#"
            serial = "{},{},{}".format(node.val, collect(node.left), collect(node.right))
            count[serial] += 1
            if count[serial] == 2:
                ans.append(node)
            return serial

        collect(root)
        return ans
        
# 序列化二叉树的步骤
"""
def collect(node):
    if not node: return "#"
    serial = "{},{},{}".format(node.val, collect(node.left), collect(node.right))
    return serial
    
其中
    count[serial] += 1
    if count[serial] == 2:
        ans.append(node)
才是顺带求取
"""
```
