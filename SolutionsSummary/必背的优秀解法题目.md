# 分治思想
- [863. 二叉树中所有距离为 K 的结点](https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/)
>给定一个二叉树（具有根结点 `root`）， 一个目标结点 `target` ，和一个整数值 `K `。       
> 返回到目标结点 `target` 距离为 `K` 的所有结点的值的列表。 答案可以以任何顺序返回。

示例 1：
```shell
输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2

输出：[7,4,1]
```

**分治思想+DFS**
```python3
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def distanceK(self, root: TreeNode, target: TreeNode, K: int) -> List[int]:
        # 从target始往其下的左右子树搜索
        def searchChildren(tar_node, K):
            if not tar_node: return
            if K == 0: ans.append(tar_node.val)
            searchChildren(tar_node.left, K - 1)
            searchChildren(tar_node.right, K - 1)
        # dfs从root始往下遍历
        def dfs(root):
            if not root: return -1
            # base case，找到target节点
            if root.val == target.val:
                searchChildren(root, K)
                return K
            # 分别从左右子树找target
            l = dfs(root.left)
            r = dfs(root.right)
            # target不存在
            if l < 0 and r < 0:
                return -1
            # 因为只有一个target，此时存在于左子树
            elif l > 0:
                # 是左子树第一个节点
                if l == 1: ans.append(root.val)
                # K > 1，则必然存在于右子树
                # 将 K - 1(即l - 1)处理，等价于当前的root是target
                else: searchChildren(root.right, l - 2)
                return l - 1
            # 存在于右子树
            else:
                if r == 1: ans.append(root.val)
                else: searchChildren(root.left, r - 2)
                return r - 1
        ans = []
        dfs(root)
        return ans
```

- [395. 至少有K个重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/)
> 找到给定字符串（由小写字符组成）中的最长子串 **T** ， 要求 **T** 中的每一字符出现次数都不少于 **k** 。输出 **T** 的长度。

示例 1:
```
输入:
s = "aaabb", k = 3

输出:
3

最长子串为 "aaa" ，其中 'a' 重复了 3 次。
```
解法：
```python3
# 分治-递归 思想
class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        if len(s) < k:
            return 0
        # 找到s中出现最少的字符
        t = min(set(s), key=s.count)
        # 最少出现的字符都大于等于K, s即最长子串
        if s.count(t) >= k:
            return len(s)
        # 分治思想，递归求得最长子串
        return max(self.longestSubstring(a, k) for a in s.split(t))
```

- [241. 为运算表达式设计优先级](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/)
> 给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 `+`, `-` 以及 `*` 。

示例 1:
```
输入: "2-1-1"
输出: [0, 2]
解释: 
((2-1)-1) = 0 
(2-(1-1)) = 2
```
解法：
```python3
class Solution:
    def diffWaysToCompute(self, input: str) -> List[int]:
        def helper(l, r, op):
            if op == '+': return l + r
            if op == '-': return l - r 
            if op == '*': return l * r

        if input.isdigit():
            return [int(input)]
        ans = []
        for i, op in enumerate(input):
            if op in {'+', '-', '*'}:
                # 分治思想
                left = self.diffWaysToCompute(input[:i])
                right = self.diffWaysToCompute(input[i + 1:])
                ans += [helper(l, r, op) for l in left for r in right]
        return ans
```

# 序列化二叉树
- [652. 寻找重复的子树](https://leetcode-cn.com/problems/find-duplicate-subtrees/)
> 给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。          
两棵树重复是指它们具有相同的结构以及相同的结点值。

```python3
class Solution(object):
    def findDuplicateSubtrees(self, root):
        count = collections.Counter()
        ans = []
        def collect(node):
            if not node: return "#"
            serial = "{},{},{}".format(node.val, collect(node.left), collect(node.right))
            count[serial] += 1
            if count[serial] == 2:
                ans.append(node)
            return serial

        collect(root)
        return ans

# 序列化二叉树的步骤
"""
def collect(node):
    if not node: return "#"
    serial = "{},{},{}".format(node.val, collect(node.left), collect(node.right))
    return serial
    
其中
    count[serial] += 1
    if count[serial] == 2:
        ans.append(node)
才是顺带求取
"""
```

# 区间问题
- [1235. 规划兼职工作](https://leetcode-cn.com/problems/maximum-profit-in-job-scheduling/)
> 你打算利用空闲时间来做兼职工作赚些零花钱。         
这里有 `n` 份兼职工作，每份工作预计从 `startTime[i]` 开始到 `endTime[i]` 结束，报酬为 `profit[i]`。               
给你一份兼职工作表，包含开始时间 `startTime`，结束时间 `endTime` 和预计报酬 `profit` 三个数组，请你计算并返回可以获得的最大报酬。         
注意，时间上出现重叠的 `2` 份工作不能同时进行。            
如果你选择的工作在时间 `X` 结束，那么你可以立刻进行在时间 `X` 开始的下一份工作。    
```shell
输入：startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]
输出：120
解释：
我们选出第 1 份和第 4 份工作， 
时间范围是 [1-3]+[3-6]，共获得报酬 120 = 50 + 70。
```
解法：
```python3
class Solution:
    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:
        jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1])
        dp = [[0, 0]]
        for s, e, p in jobs:
            i = bisect.bisect_left(dp, [s + 1]) - 1
            if dp[i][1] + p > dp[-1][1]:
                dp.append([e, dp[i][1] + p])
        return dp[-1][1]
```

