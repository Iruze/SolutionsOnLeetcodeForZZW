# I. 0-1背包 vs 完全背包

### i). 0-1背包

**sum_v[i][j]表示将前i件物品列为备选，背包容量为j时，能获得的最大价值；w[i]表示第i件物品的重量，v[i]表示第i件物品的价值:**

```python
if j >=w[i]:
    sum_v[i][j] = max(sum_v[i-1][j-w[i]] + v[i], sum_v[i-1][j])
else:
    sum_v[i][j] = sum_v[i-1][j]
```
简化为一维数组：
```python3
if j >= w[i]:
    sum_v[j] = max(sum_v[j - w[i]] + v[i], sum_v[j])
```
需要注意的是两点：
> * 循环时，离散的选择在外循环，连续的选择在内循环：        
第i件的价值是离散的，0-max重量，重量是连续的
>         
> * 0-1背包内循环是**反向的**，区别于下面完全背包的内循环是正向的

### ii). 完全背包
完全背包中，假定物品i是可以无限选择的，此时求背包背走的最大价值。   
完全背包的一维递推公式跟0-1背包一模一样：
```python3
if j >= w[i]:
    sum_v[j] = max(sum_v[j - w[i]] + v[i], sum_v[j])
```

区别在于，内循环是正向的：

# II. Leetcode解题总结

参考： [希望用一种规律搞定背包问题](https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/)

总结来说， **背包问题**细分为三类。

>i). 组合问题：
>- [377. 组合总和 Ⅳ]()
>- [494. 目标和]()
>- [518. 零钱兑换 II]()

>ii). True、False问题：
>-[139. 单词拆分]()
>-[416. 分割等和子集]()

>iii)、最大最小问题：
>-[474. 一和零]()
>-[322. 零钱兑换]()


>组合问题公式
```python
dp[i] += dp[i-num]
```

>True、False问题公式
```python
dp[i] = dp[i] or dp[i-num]
```

>最大最小问题公式
```python
dp[i] = min(dp[i], dp[i-num]+1)或者dp[i] = max(dp[i], dp[i-num]+1)
```

**背包问题技巧：**
>如果是`0-1`背包，即数组中的元素不可重复使用，`nums`放在外循环，`target`在内循环，且内循环倒序；
```python
for num in nums:
    for i in range(target, nums-1, -1):
```

>如果是完全背包，即数组中的元素可重复使用，`nums`放在外循环，`target`在内循环。且内循环正序。
```python
for num in nums:
    for i in range(nums, target+1):
```

>如果组合问题需考虑元素之间的顺序，需将`target`放在外循环，将`nums`放在内循环。
```python
for i in range(1, target+1):
    for num in nums:
```

III. Leetcode例题

- [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

> 给定一个**只包含正整数**的**非空**数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意:
```shell
每个数组中的元素不会超过 100
数组的大小不会超过 200
```

示例 1:
```shell
输入: [1, 5, 11, 5]
输出: true
解释: 数组可以分割成 [1, 5, 5] 和 [11].
```

示例 2:
```shell
输入: [1, 2, 3, 5]
输出: false
解释: 数组不能分割成两个元素和相等的子集.
```
code:

```python3
# 1. 如果nums的总和为奇数，则不可能分为两个和相等的子数组
# 2. 如果nums的总和为偶数，则等价于：从nums中选出如果个子数组，使得其总和等于 SUM/2
#    这时，等价于 0-1 背包问题。
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        SUM = sum(nums)
        # 如果nums的总和为奇数，则不可分，返回False
        if SUM & 1:
            return False
        # 套用 0-1 背包问题：从nums中选择若干元素，使得它们构成的子数组总和等于 SUM/2
        SUM = SUM // 2
        res = [False] * (SUM + 1)
        # dp的base case
        res[0] = True
        # 1. 离散的选择作为外循环
        for num in nums:
            # 2. 0-1 背包是内循环反向迭代
            for j in range(SUM, num - 1, -1):
                res[j] = res[j] or res[j - num]
        return res[SUM]
```

# II. 完全背包

   
- [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)    
> 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

示例 1:

```shell
输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
```

示例 2:
```shell
输入: coins = [2], amount = 3
输出: -1
```

说明:

```shell
你可以认为每种硬币的数量是无限的。
```

直接看code:

```python3
class Solution(object):
    def coinChange(self, coins, amount):
        """
        :type coins: List[int]
        :type amount: int
        :rtype: int
        """
        if not coins or amount < 1: return 0
        dp = [amount + 1] * (amount + 1)
        dp[0] = 0
        # 1. 离散的在外循环
        for coin in coins:
            # 2. 内循环是正向的
            for i in range(coin, amount + 1):
                dp[i] = min(dp[i], dp[i - coin] + 1)
        return -1 if dp[amount] > amount else dp[amount]
```

#### Ref:
- [背包，个人意见，大家分享](https://leetcode-cn.com/problems/coin-lcci/solution/bei-bao-jiu-jiang-ge-ren-yi-jian-da-jia-fen-xiang-/)
