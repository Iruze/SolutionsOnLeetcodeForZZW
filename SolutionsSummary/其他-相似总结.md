### 自然序列中第n个数 VS 自然序列中1出现的次数
- [400. 第N个数字](https://leetcode-cn.com/problems/nth-digit/)
> 在无限的整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...中找到第 n 个数字。

<details>
<summary>题解</summary>
    
```python3
class Solution:
    def findNthDigit(self, n: int) -> int:
        # n - 1的目的在于，后面first_num的第一个索引从0开始
        n -= 1
        # pow(2, 31) < pow(10, 11), 在32位证书范围内
        for digit in range(1, 11):
            # [first_num]表示每一组第一个数
            # [1]23456789       [10]11...99     [100]101...999
            first_num = 10 ** (digit - 1)
            if n < 9 * first_num * digit:
                return int(str(first_num + n / digit)[n % digit])
            n -= 9 * first_num * digit
        return -1
```
</details>

- [233. 1～n整数中1出现的次数](https://leetcode-cn.com/problems/number-of-digit-one/)
> 输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。   
例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。

<details>
<summary>题解</summary>
    
参考： [找规律-通用的解法](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/xiang-jie-gui-lu-yong-shi-0ms-by-sircarol/)
```python3
class Solution:
    def countDigitOne(self, n: int) -> int:
        if n <= 0: return 0
        if n <= 9: return 1
        ans = 0
        i = 1
        target = 1
        m = 9 - target
        while i <= n:
            a, b = n // i, n % i
            ans += (a + m) // 10 * i + (b + 1 if a % 10 == target else 0)
            i *= 10
        return ans
```
</details>
