**必须背诵一些短小精悍、实用价值高的模板，这样才能在解题时候快速突击，举重若轻**

### No1. 两个数组中的最小差值
```python3
arr1.sort()
arr2.sort()
idx1, idx2 = 0, 0
ans = float('Inf')
while idx1 < len(arr1) and idx2 < len(arr2):
    ans = min(ans, abs(arr1[idx1] - arr2[idx2]))
    
    if arr1[idx1] < arr2[idx2]:
        idx1 += 1
    elif arr1[idx1] > arr2[idx2]:
        idx2 += 1
    else:
        return 0
```


### No2. 整数数组中两两之差绝对值最小的值

- O(nlogn), O(1), 排序，做差
- O(n), O(n), 桶排序

```python3
# 方法一： 桶排序， O(n), O(n)
def minDiff(self, nums):
    # 类似于计数排序（桶排序）
    diff = max(nums) - min(nums)
    hashtab = [0 for _ in range(diff + 1)]
    for num in nums:
        hashtab[num - min(nums)] += 1
    last = 0
    ans = float('Inf')
    # hashtab[0] = min(nums), 必然存在于hashtab
    for i in range(1, diff + 1):
        if hashtab[i] > 1: return 0
        if hashtab[i] == 1:
            ans= min(ans, i - last)
            last = i
    return ans
    
# 方法二： 快排，O(nlogn), O(1)
def minDiff(self, nums):
    nums.sort()
    return min(nums[i + 1] - nums[i] for i in range(len(nums)
```

### No3. 求nums中前k个最大序列(不一定是最大上升子序列)
```python3
def maxKSeq(nums, k):
    giveup = len(nums) - k
    stack = []
    for i, v in enumerate(nums):
        # 注意是 stack[-1] < v，没有等于
        while stack and stack[-1] < v and giveup:
            stack.pop()
            giveup -= 1
        stack.append(v)
```

### No4. 合并两个列表，维持各自元素原来位置，且合并后的值最大
```python3
# 合并nums1和nums2序列
def merge(nums1, nums2):
    nums = []
    while nums1 and nums2:
        nums.append(max(nums1, nums2).pop(0))
    return nums + (nums1 or nums2)
```
