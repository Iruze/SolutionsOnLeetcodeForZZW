# 山脉数组
- [852. 山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)
用的是 **mid和mid + 1**的比较，而不是 **lo, mid, hi**的比较
> 我们把符合下列属性的数组 `A` 称作山脉：      
`A.length >= 3`
存在 `0 < i < A.length - 1` 使得`A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]`
给定一个确定为山脉的数组，返回任何满足 `A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]` 的 `i` 的值。
示例 2：
```shell
输入：[0,2,1,0]
输出：1
```
二分解法：
```python3
class Solution:
    def peakIndexInMountainArray(self, A: List[int]) -> int:
        lo, hi = 0, len(A) - 1
        while lo < hi:
            mid = lo + ((hi - lo) >> 1)
            # 不是 lo, mid, hi 的比较，而是mid, mid + 1的比较
            if A[mid] < A[mid + 1]:
                lo = mid + 1
            else:
                hi = mid
        return lo
```
- [162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)
> 峰值元素是指其值大于左右相邻值的元素。       
给定一个输入数组 `nums`，其中 `nums[i] ≠ nums[i+1]`，找到峰值元素并返回其索引。          
数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。         
你可以假设 `nums[-1] = nums[n] = -∞`。        

示例 1:
```
输入: nums = [1,2,3,1]
输出: 2
解释: 3 是峰值元素，你的函数应该返回其索引 2。
```
跟山脉数组类的代码，不过思路是：
```shell
规律一：如果nums[i] > nums[i+1]，则在i之前一定存在峰值元素

规律二：如果nums[i] < nums[i+1]，则在i+1之后一定存在峰值元素
```
```python3
class Solution:
    def peakIndexInMountainArray(self, A: List[int]) -> int:
        lo, hi = 0, len(A) - 1
        while lo < hi:
            mid = lo + ((hi - lo) >> 1)
            if A[mid] < A[mid + 1]:        # mid右边一定存在山峰
                lo = mid + 1
            else:                          # mid左边一定存在山峰
                hi = mid
        return lo
```

- [1095. 山脉数组中查找目标值](https://leetcode-cn.com/problems/find-in-mountain-array/)
> 给你一个 山脉数组 `mountainArr`，请你返回能够使得 `mountainArr.get(index)` 等于 `target` 最小 的下标 `index` 值。     
如果不存在这样的下标 `index`，就请返回 `-1`。     
何为山脉数组？如果数组 `A` 是一个山脉数组的话，那它满足如下条件：     
首先，`A.length >= 3`        
其次，在 `0 < i < A.length - 1` 条件下，存在 `i` 使得：          
**A[0] < A[1] < ... A[i-1] < A[i]**       
**A[i] > A[i+1] > ... > A[A.length - 1]**       
你将 不能直接访问该山脉数组，必须通过 `MountainArray` 接口来获取数据：        
`MountainArray.get(k)` - 会返回数组中索引为`k` 的元素（下标从 `0` 开始）       
`MountainArray.length()` - 会返回该数组的长度          
###### 思路： 
1. 利用  [852. 山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/) 找到峰顶的索引`peak`, 将`山脉数组`转化为`两个有序数组`；
2. 从 `[0, peak] `二分搜索`target`；
3. 从 `[peak - 1, n - 1]` 二分搜索`target`.
```python3
# """
# This is MountainArray's API interface.
# You should not implement it, or speculate about its implementation
# """
#class MountainArray:
#    def get(self, index: int) -> int:
#    def length(self) -> int:

class Solution:
    def findInMountainArray(self, target: int, mountain_arr: 'MountainArray') -> int:
        n = mountain_arr.length()
        # 1. 找到峰顶的索引peak
        lo, hi = 0, n - 1
        while lo < hi:
            mid = lo + ((hi - lo) >> 1)
            if mountain_arr.get(mid) > mountain_arr.get(mid + 1):
                hi = mid
            else:
                lo = mid + 1
        peak = lo
        # 2. 从 [0, peak] 二分搜索target
        lo, hi = 0, peak
        while lo < hi:
            mid = lo + ((hi - lo) >> 1)
            if mountain_arr.get(mid) == target:
                return mid
            elif mountain_arr.get(mid) < target:
                lo = mid + 1
            else:
                hi = mid
        # 如果左端 [0, peak] 找到了target
        if mountain_arr.get(lo) == target:
            return lo
        
        # 3. 从 [peak - 1, n - 1] 二分搜索target
        lo, hi = peak - 1, n - 1
        while lo < hi:
            mid = lo + ((hi - lo) >> 1)
            if mountain_arr.get(mid) == target:
                return mid
            elif mountain_arr.get(mid) < target:
                hi = mid
            else:
                lo = mid + 1
        return lo if mountain_arr.get(lo) == target else -1
```

# 旋转数组
- [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)
> 假设按照升序排序的数组在预先未知的某个点上进行了旋转。         
( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。         
请找出其中最小的元素。         
你可以假设数组中不存在重复元素。        

示例 1:
```shell
输入: [3,4,5,1,2]
输出: 1
```

- [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)
> 假设按照升序排序的数组在预先未知的某个点上进行了旋转。         
( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。       
搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 `-1` 。         
你可以假设数组中不存在重复的元素。         
你的算法时间复杂度必须是 `O(log n)` 级别。

示例 1:
```shell
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
```
