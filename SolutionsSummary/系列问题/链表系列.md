# 链表反转
- [剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)
> 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
<details>
    <summary>解法一: 迭代解法(最优)</summary>
    
```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        pre = None
        cur = head
        while cur:
            tmp = cur.next
            cur.next = pre
            pre = cur
            cur = tmp
        return pre
```
</details>

<details>
    <summary>解法二: 递归解法</summary>
    
```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        last = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return last
```
</details>

- [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)
> 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。    
说明:   
1 ≤ m ≤ n ≤ 链表长度。

<details>
    <summary>解法一: 迭代解法(最优)</summary>
    
```python
class Solution:
    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:
        # 因为m可能为1， 头结点也在反转里面，故需要dummy
        dummy = ListNode(-1)
        dummy.next = head
        pre, cur = dummy, head
        n -= m
        while m != 1:
            pre, cur = cur, cur.next
            m -= 1
        # 左边m处断开的两头
        l1, l2 = pre, cur
        while n != -1:
            tmp = cur.next
            cur.next = pre
            pre = cur
            cur = tmp
            n -= 1
        # 右边n处断开的两处
        r1, r2 = pre, cur
        # m-n段反转，m处和n处的节点指向改变
        l1.next, l2.next = r1, r2
        return dummy.next
```
</details>


<details>
    <summary>解法二:递归解法</summary>
    
```python
class Solution:
    successor = None

    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:
        if m == 1:
            return self.reverseN(head, n)
        head.next = self.reverseBetween(head.next, m - 1, n - 1)
        return head
    
    def reverseN(self, head, n):
        if n == 1:
            self.successor = head.next
            return head
        last = self.reverseN(head.next, n - 1)
        head.next.next = head
        head.next = self.successor
        return last
```
</details>

# 链表排序
- [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)
> 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。     
在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序.



#　技巧
- 找链表中点，快慢指针的起始是`head`和`head.next`，　而不是都是`head`
```python
slow, fast = head, head.next
while fast and fast.next:
    fast, slow = fast.next.next, slow.next
mid, slow.next = slow.next, None
```
