# 链表反转
- [剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)
> 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
<details>
    <summary>解法一: 迭代解法(最优)</summary>
    
```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        pre = None
        cur = head
        while cur:
            tmp = cur.next
            cur.next = pre
            pre = cur
            cur = tmp
        return pre
```
</details>

<details>
    <summary>解法二: 递归解法</summary>
    
```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        last = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return last
```
</details>

- [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)
> 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。    
说明:   
1 ≤ m ≤ n ≤ 链表长度。

<details>
    <summary>解法一: 迭代解法(最优)</summary>
    
```python
class Solution:
    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:
        # 因为m可能为1， 头结点也在反转里面，故需要dummy
        dummy = ListNode(-1)
        dummy.next = head
        pre, cur = dummy, head
        n -= m
        while m != 1:
            pre, cur = cur, cur.next
            m -= 1
        # 左边m处断开的两头
        l1, l2 = pre, cur
        while n != -1:
            tmp = cur.next
            cur.next = pre
            pre = cur
            cur = tmp
            n -= 1
        # 右边n处断开的两处
        r1, r2 = pre, cur
        # m-n段反转，m处和n处的节点指向改变
        l1.next, l2.next = r1, r2
        return dummy.next
```
</details>


<details>
    <summary>解法二:递归解法</summary>
    
```python
class Solution:
    successor = None

    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:
        if m == 1:
            return self.reverseN(head, n)
        head.next = self.reverseBetween(head.next, m - 1, n - 1)
        return head
    
    def reverseN(self, head, n):
        if n == 1:
            self.successor = head.next
            return head
        last = self.reverseN(head.next, n - 1)
        head.next.next = head
        head.next = self.successor
        return last
```
</details>

# 链表排序
- [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)
> 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。     
在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序.


<details>
    <summary>解法一:递归－Ｏ(n)空间复杂度</summary>
    
```python
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        slow, fast = head, head.next
        while fast and fast.next:
            slow, fast = slow.next, fast.next.next
        mid, slow.next = slow.next, None
        left = self.sortList(head)
        right = self.sortList(mid)
        dummy = node = ListNode(-1)
        while left and right:
            if left.val < right.val:
                node.next = left
                left = left.next
            else:
                node.next = right
                right = right.next
            node = node.next
        node.next = left if left else right
        return dummy.next
```
</details>


<details>
    <summary>解法二：迭代－Ｏ(1)空间复杂度</summary>
    
```python
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        # 第一步：　链表长度
        node = head
        length = 0
        while node:
            node = node.next
            length += 1
        
        dummy = ListNode(-1)
        dummy.next = head
        intv = 1
        # 第二步: 一共log(length)个周期(迭代轮询),每个周期都是轮询整个链表
        while intv < length:
            pre, h = dummy, dummy.next
            # 第三步: 在当前长度为intv的轮询周期
            while h:
                h1, i = h, intv                             # h1, h2分别是待比较的左右子链的头结点
                while h and i:
                    h = h.next
                    i -= 1
                if i:                                       # h=None, i>0, 说明只有一个子链, 右子链为空
                    break
                h2, i = h, intv
                while h and i:
                    h = h.next
                    i -= 1
                l1, l2 = intv, intv - i                     # 左子链为2的整数次幂(比如2^k), 右边则比2^k小一点,小i
                while l1 and l2:                            # 合并两个有序链表
                    if h1.val < h2.val:
                        pre.next = h1
                        h1 = h1.next
                        l1 -= 1
                    else:
                        pre.next = h2
                        h2 = h2.next
                        l2 -= 1
                    pre = pre.next
                pre.next = h1 if l1 else h2
                while l1 > 0 or l2 > 0:                     # h1或者h2还有剩下的部分,pre不在剩下部分的尾部
                    pre = pre.next                          # ,需要移动到尾部
                    l1, l2 = l1 - 1, l2 - 1                 # l1, l2同时减少,其中有一个必然为负,但是它没有意义,所以无影响
                pre.next = h                                # 当前轮次合并完成, 接着开始后面的一对左右子链
            intv <<= 1                                      # 下一个子链的最大长度加倍

        return dummy.next
```
</details>
参考: 
[Sort List （归并排序链表](https://leetcode-cn.com/problems/sort-list/solution/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/)


# 技巧
- 找链表中点，快慢指针的起始是`head`和`head.next`，　而不是都是`head`
```python
slow, fast = head, head.next
while fast and fast.next:
    fast, slow = fast.next.next, slow.next
mid, slow.next = slow.next, None
```
